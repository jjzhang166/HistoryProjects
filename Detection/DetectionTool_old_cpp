#include "DetectionTool.h"
#include <process.h>

/*整体线程控制全局变量*/
extern bool g_threadWait;

/*条码全局变量*/
extern QString g_code;

/*静态变量初始化*/
QString DetectionTool::m_lastError = "No Error";

void DetectionTool::setLastError(const QString& err)
{
#ifdef QT_DEBUG
	qDebug() << err << endl;
#endif
	m_lastError = err;
}

void DetectionTool::setLastError(const QString& err, bool addItem, bool msgBox)
{
#ifdef QT_DEBUG
	qDebug() << err << endl;
#endif
	m_lastError = err;

	if (addItem)
	{
		addListItem(m_lastError);
	}

	if (msgBox)
	{
		QMessageBox::warning(static_cast<QWidget*>(nullptr), "错误", err);
	}
}

void DetectionTool::formatWriteLog(int logName, const char* format, ...)
{
	va_list ap;
	va_start(ap, format);
	m_logData[logName] = LOG_INPUT(format);
	va_end(ap);
}

bool DetectionTool::udsEncodeConvert(VersonConfig* versionInfo)
{
	bool bRet = false;
	do
	{
		std::string strDataType = versionInfo->encode;
		if (strDataType.find("ASCII") != std::string::npos)
		{

		}
		else if (strDataType.find("U08") != std::string::npos)
		{
			for (int i = 8; i < 4 + 8; i++)
			{
				versionInfo->read[i] += ('1' - 1);
			}
		}
		else if (strDataType.find("ASCR4") != std::string::npos)
		{
			for (int i = versionInfo->size - 4; i < versionInfo->size; i++)
			{
				versionInfo->read[i] += ('1' - 1);
			}
		}
		else if (strDataType.find("USN") != std::string::npos
			|| strDataType.find("BIN") != std::string::npos
			|| strDataType.find("BCD") != std::string::npos)
		{
			for (int i = 0; i < versionInfo->size; i++)
			{
				versionInfo->read[i] += ('1' - 1);
			}
		}
		else if (strDataType.find("INT") != std::string::npos)
		{
			UCHAR ucTemp = versionInfo->read[0];
			versionInfo->read[0] = versionInfo->read[3];
			versionInfo->read[3] = ucTemp;

			ucTemp = versionInfo->read[1];
			versionInfo->read[1] = versionInfo->read[2];
			versionInfo->read[2] = ucTemp;

			int iTemp = *(int*)&versionInfo->read[0];
			sprintf(versionInfo->read, "%d", iTemp);
		}
		else if (strDataType.find("ASCBCD44") != std::string::npos)
		{
			char szEnd[64] = { 0 };
			strncpy(szEnd, &versionInfo->read[7], versionInfo->size - 7);
			char szMid[64] = { 0 };
			for (int i = 3; i < 4 + 3; i++)
			{
				char temp[8] = { 0 };
				sprintf(temp, "%02x", versionInfo->read[i]);
				sprintf(&szMid[strlen(szMid)], "%s", temp);
			}
			sprintf(&versionInfo->read[3], "%s%s", szMid, szEnd);
		}
		else
		{
			break;
		}

		//祛除头、尾的空格
		std::string strVer = versionInfo->read;
		strVer.erase(0, strVer.find_first_not_of(" "));
		strVer.erase(strVer.find_last_not_of(" ") + 1);
		strcpy(versionInfo->read, strVer.c_str());
		bRet = true;
	} while (false);
	return bRet;
}

DetectionTool::DetectionTool(const DetectionType& type, QObject* parent)
	: QThread(parent)
{
	qRegisterMetaType<testResult_t>("testResult_t");
	qRegisterMetaType<bool*>("bool*");
	m_detectionType = type;
}

DetectionTool::DetectionTool(const DetectionType& type, std::initializer_list<LogType> logType, QObject* parent)
{
	qRegisterMetaType<testResult_t>("testResult_t");
	qRegisterMetaType<bool*>("bool*");
	m_detectionType = type;
	setWriteBaseDl(logType);
}

DetectionTool::~DetectionTool()
{
#ifdef QT_DEBUG
	qDebug() << __FUNCTION__ << endl;
#endif
	JsonTool::deleteInstance();
#if OPEN_VIDEO
	if (m_detectionType != DetectionType::DT_HARDWARE)
	{
		cvReleaseImage(&m_cvAnalyze);
		cvReleaseImageHeader(&m_cvPainting);

		if (m_captureCard.cardName == "MV800")
		{
			m_mv800Mgr.DeinitCard();
		}
		else
		{
			if (m_milCaptureThread)
			{
				delete m_milCaptureThread;
				m_milCaptureThread = nullptr;
			}
		}
	}
#endif //!OPEN_VIDEO
	if (m_detectionType == DetectionType::DT_DVR)
	{
		finishExternalProgram("win32_demo.exe");
	}

	threadQuit();
}

bool DetectionTool::initInstance()
{
	bool result = false;
	do
	{
		m_hashCode.systemStatus = typeid(DvrSystemStatus).hash_code();

		m_hashCode.wifiStatus = typeid(DvrWifiStatus).hash_code();

		m_hashCode.ethernetStatus = typeid(DvrEthernetStatus).hash_code();

		m_hashCode.sdCardStatus = typeid(DvrSdCardStatus).hash_code();

		m_jsonTool = JsonTool::getInstance();
		if (!m_jsonTool)
		{
			setLastError("m_jsonTool分配内存失败");
			break;
		}

		if (!m_jsonTool->initInstance())
		{
			setLastError(m_jsonTool->getLastError());
			break;
		}

		m_deviceConfig = m_jsonTool->getParsedDeviceConfig();

		m_hardwareConfig = m_jsonTool->getParseHardwareConfig();

		m_relayConfig = m_jsonTool->getParsedRelayConfig();

		m_imageCheckConfig = m_jsonTool->getParsedImageConfig();

		m_rangeConfig = m_jsonTool->getParsedRangeConfig();

		m_thresholdConfig = m_jsonTool->getParsedThresholdConfig();

		m_hwdInfo = m_jsonTool->getParsedHwdConfig();

		m_udsInfo = m_jsonTool->getParsedUdsConfig();

#if OPEN_VIDEO
		if (m_detectionType != DetectionType::DT_HARDWARE)
		{
			setCaptureCardAttribute(m_deviceConfig.captureName);

			m_cvAnalyze = cvCreateImage(cvSize(m_captureCard.width, m_captureCard.height), 8, 3);
			if (!m_cvAnalyze)
			{
				setLastError("m_cvAnalyze分配内存失败");
				break;
			}

			m_cvPainting = cvCreateImageHeader(cvSize(m_captureCard.width, m_captureCard.height), 8, 3);
			if (!m_cvPainting)
			{
				setLastError("m_cvPainting分配内存失败");
				break;
			}

			if (m_deviceConfig.captureName == "MV800")
			{
				if (!m_mv800Mgr.InitCard(1))
				{
					setLastError("初始化MV800采集卡失败");
					break;
				}
			}
			else
			{
				m_milCaptureThread = new(std::nothrow) MilCaptureThread(this);
				if (!m_milCaptureThread)
				{
					setLastError("m_milCaptureThread分配内存失败");
					break;
				}
			}
		}
#endif// !OPEN_VIDEO

		m_canConnMgr = m_canConnFactory.GetConnMgrInstance(m_deviceConfig.canName.toLatin1());
		if (!m_canConnMgr)
		{
			setLastError("CAN通信初始化失败");
			break;
		}

#ifdef QT_DEBUG
		m_canConnMgr->EnableDebugInfo(true);
#endif

		//m_canConnMgr->EnableSaveLog(true);

		m_udsApplyMgr = m_udsFactory.GetConnMgrInstance(m_deviceConfig.udsName.toLatin1());
		if (!m_udsApplyMgr)
		{
			setLastError("UDS通信初始化失败");
			break;
		}

		m_udsApplyMgr->SetIConnMgr(m_canConnMgr);

		if (!m_canSender.Init(m_canConnMgr))
		{
			setLastError("CanSender初始化失败");
			break;
		}

		if (m_detectionType == DetectionType::DT_DVR)
		{
			if (!m_sfrServer.startListen())
			{
				setLastError(m_sfrServer.getLastError());
				break;
			}

			finishExternalProgram("win32_demo.exe");

			QString programName = "\\External\\sfr_client\\bin\\win32_demo.exe";
			if (!startExternalProgram(programName, SW_NORMAL))
			{
				setLastError(QString("启动%1应用程序失败").arg(programName));
				break;
			}
		}
		result = true;
	} while (false);
	return result;
}

void DetectionTool::setTestSequence(const int& testSequence)
{
	m_testSequence = testSequence;
}

bool DetectionTool::openDevice()
{
	bool result = false;
	do
	{
		if (!m_canConnMgr->Connect(500, 0))
		{
			setLastError("连接CAN卡失败", false, true);
		}

		if (!m_power.Open(m_hardwareConfig.powerPort, m_hardwareConfig.powerBaud, m_hardwareConfig.powerVoltage))
		{
			setLastError("打开电源失败", false, true);
		}

		if (!m_relay.Open(m_hardwareConfig.relayPort, m_hardwareConfig.relayBaud))
		{
			setLastError("打开继电器失败", false, true);
		}

		if (!m_voltage.Open(m_hardwareConfig.voltagePort, m_hardwareConfig.voltageBaud))
		{
			setLastError("打开电压表失败", false, true);
		}

#if OPEN_VIDEO
		if (m_detectionType != DetectionType::DT_HARDWARE)
		{
			if (m_deviceConfig.captureName == "MV800")
			{
				if (!m_mv800Mgr.Connect(NULL, NULL, m_captureCard.width, m_captureCard.height, Mv800CaptureThread, 1, this))
				{
					setLastError(QString("连接到MV800采集卡失败,原因 %1").arg(G_TO_Q_STR(m_mv800Mgr.GetLastError())), false, true);
				}
			}
			else
			{
				if (!m_milCaptureThread->openMil("Config/ntsc.dcf"))
				{
					setLastError(QString("采集卡初始化失败,原因 %1").arg(m_lastError), false, true);
				}
				else
				{
					m_milCaptureThread->start();
				}
			}
		}
#endif //! OPEN_VIDEO
		setScanCodeDlg(result);
		m_connect = result = true;
	} while (false);
	return result;
}

bool DetectionTool::closeDevice()
{
	bool result = false;
	do
	{
		setScanCodeDlg(m_connect = false);
		if (!m_canConnMgr->DisConnect())
		{
			setLastError("CAN断开连接失败", false, true);
		}

		if (!m_power.Output(false))
		{
			setLastError("关闭电源失败", false, true);
		}

		Sleep(100);

		if (!m_power.Close())
		{
			setLastError("关闭电源失败", false, true);
		}

		if (!m_relay.Close())
		{
			setLastError("关闭继电器失败", false, true);
		}

		m_voltage.Close();

#if OPEN_VIDEO

		if (m_detectionType != DetectionType::DT_HARDWARE)
		{
			if (m_captureCard.cardName == "MV800")
			{
				m_mv800Mgr.DisConnect();
			}
			else
			{
				m_milCaptureThread->closeMil();
			}
		}
#endif// !OPEN_VIDEO
		result = true;
	} while (false);
	return result;
}

bool DetectionTool::prepareTest(LaunchProc launchProc, void* args)
{
	setCurrentStatus("准备测试");
	setTestResult(TestResult::TR_TS);
	bool result = false;
	do
	{
		m_canConnMgr->SetDetectionData(Q_TO_C_STR(m_deviceConfig.modelName), Q_TO_C_STR(g_code));

		clearListItem();

		m_elapsedTime = GetTickCount();

		addListItem(Q_SPRINTF("第%u块产品开始测试", m_total), false);

		initBaseDl();

		addListItem("等待成功启动,请耐心等待...");

		if (!m_power.Output(true))
		{
			setLastError("电源通讯失败,请检查连接");
			break;
		}

		msleep(300);

		if (m_detectionType == DetectionType::DT_AVM)
		{
			const int portArray[] = {
				m_relayConfig.acc
				,m_relayConfig.gnd
				,m_relayConfig.pinboard
			};

			bool success = true;
			for (int i = 0; i < sizeof(portArray) / sizeof(int); i++)
			{
				if (!m_relay.SetOneIO(portArray[i], true))
				{
					success = false;
					break;
				}
				msleep(300);
			}
			LOG_ASSERT(success, "继电器通讯失败,请检查连接");
		}
		else if (m_detectionType == DetectionType::DT_DVR)
		{
			LOG_ASSERT(m_relay.SetOneIO(m_relayConfig.acc, true)
				, "继电器通讯失败,请检查连接");
			msleep(300);

			startDvrTimeSync();

			addListItem("正在检测系统状态");
			size_t startTime = GetTickCount();
			if (!autoProcessDvrStatus<DvrSystemStatus>())
			{
				setLastError("系统初始化失败");
				break;
			}
			addListItem(Q_SPRINTF("检测系统状态正常,用时:%.3f秒", float(GetTickCount() - startTime) / 1000.000f));

			/*addListItem("正在检测网络状态");
			startTime = GetTickCount();
			if (m_dvrNetworkType == DvrNetworkType::DNT_ETHERNET)
			{
				if (!autoProcessDvrStatus<DvrEthernetStatus>())
				{
					setLastError("网络初始化失败");
					break;
				}
			}
			else
			{
				if (!autoProcessDvrStatus<DvrWifiStatus>())
				{
					setLastError("网络初始化失败");
					break;
				}
			}
			addListItem(Q_SPRINTF("检测网络状态正常,用时:%.3f秒", float(GetTickCount() - startTime) / 1000.000f));*/
		}

		if (m_detectionType != DetectionType::DT_DVR)
		{
			if (launchProc && args)
			{
				size_t startTime = GetTickCount();
				if (!launchProc(args))
				{
					setLastError("初始化系统异常");
					setCurrentStatus("状态异常", true);
					break;
				}
				addListItem(Q_SPRINTF("系统成功启动用时 %.2f秒", static_cast<float>(GetTickCount() - startTime) / 1000));
			}
			else
			{
				msleep(15000);
			}
			setCurrentStatus("状态正常", true);
		}
		m_canSender.Start();
		result = true;
	} while (false);
	addListItem(Q_SPRINTF("准备测试 %s", OK_NG(result)), false);
	return result;
}

bool DetectionTool::finishTest(QFile& file, bool success)
{
	bool result = false;
	do
	{
		if (success)
		{
			++m_total;
		}

		addListItem(Q_SPRINTF("测试用时 %.2f秒", (float)(GetTickCount() - m_elapsedTime) / 1000), false);

		setTestResult(success ? TestResult::TR_OK : TestResult::TR_NG);

		m_canSender.Stop();

		if (!m_power.Output(false))
		{
			setLastError("电源通讯失败,请检查连接");
			break;
		}

		msleep(300);

		if (m_detectionType == DetectionType::DT_AVM)
		{
			const int portArray[] = {
				m_relayConfig.acc
				,m_relayConfig.gnd
				,m_relayConfig.pinboard
			};

			bool success = true;
			for (int i = 0; i < sizeof(portArray) / sizeof(int); i++)
			{
				if (!m_relay.SetOneIO(portArray[i], false))
				{
					success = false;
					break;
				}
				msleep(300);
			}
			LOG_ASSERT(success, "继电器通讯失败,请检查连接");
		}
		else if (m_detectionType == DetectionType::DT_DVR)
		{
			stopDvrTimeSync();

			if (!m_relay.SetOneIO(m_relayConfig.acc, false))
			{
				setLastError("继电器通讯失败,请检查连接");
				break;
			}

			msleep(300);

			if (getDvrSoundLigth())
			{
				if (!setDvrSoundLight(false))
				{
					setLastError("继电器通讯失败,请检查连接");
					break;
				}
			}
		}
		else
		{
			LOG_ASSERT(m_relay.SetAllIO(false), "继电器通讯失败,请检查连接");
		}
		result = true;
	} while (false);

	bool save = success ? true : setQuestionBox("提示", getLastError() + "\n检测NG是否要保存日志");
	if (save)
	{
		if (!writeDefaultLog(file, success))
		{
			result = false;
		}
	}

	//m_canConnMgr->NewLogFile();

	if (!success)
	{
		setUnlockDlg();
	}
	return result;
}

bool DetectionTool::checkVersion()
{
	setCurrentStatus("检测版本号");
	bool result = false, success = true;
	do
	{
		auto info = m_udsInfo.ver;

		for (int i = 0; i < MAX_VERSION_COUNT; i++)
		{
			if (!info[i].valid)
			{
				continue;
			}

			if (!m_udsApplyMgr->ReadDataByIdentifier(info[i].did[0],
				info[i].did[1], &info[i].size, (UCHAR*)info[i].read))
			{
				strcpy(info[i].read, "读取失败");
				success = info[i].result = false;
				addListItem(QString("%1  %2  %3").arg(G_TO_Q_STR(info[i].name), G_TO_Q_STR(info[i].read), OK_NG(info[i].result)));
				continue;
			}

			//类型转换
			udsEncodeConvert(&info[i]);

			if (0 != strncmp(info[i].setup, info[i].read, strlen(info[i].setup)))
			{
				info[i].result = false;
				success = false;
			}
			else
			{
				info[i].result = true;
			}

			addListItem(QString("%1  %2  %3").arg(G_TO_Q_STR(info[i].name), G_TO_Q_STR(info[i].read), OK_NG(info[i].result)));

			msleep(50);
		}

		if (!success)
		{
			setLastError("检测版本号失败");
			break;
		}
		result = true;
	} while (false);
	addListItem(Q_SPRINTF("检测版本号 %s", OK_NG(result)), false);
	return result;
}

bool DetectionTool::checkDtc()
{
	setCurrentStatus("检测DTC");
	bool result = false, success = true;
	do
	{
		int count = 0;
		UCHAR dtcInfo[512] = { 0 };
		if (!m_udsApplyMgr->SafeReadDTCInformation(02, 0xff, &count, dtcInfo))
		{
			break;
		}

		//判断DTC信息
		for (int i = 0; i < count / 4; i++)
		{
			for (int j = 0; j < MAX_DTC_COUNT; j++)
			{
				if (m_udsInfo.dtc[j].ignore || !m_udsInfo.dtc[j].valid)
				{
					continue;
				}

				if (dtcInfo[i * 4 + 0] == m_udsInfo.dtc[j].dtc[0]
					&& dtcInfo[i * 4 + 1] == m_udsInfo.dtc[j].dtc[1]
					&& dtcInfo[i * 4 + 2] == m_udsInfo.dtc[j].dtc[2])
				{
					m_udsInfo.dtc[j].dtc[3] = dtcInfo[i * 4 + 3];
					m_udsInfo.dtc[j].exist = true;
					success = false;
					addListItem(Q_SPRINTF("%s  存在  %d", m_udsInfo.dtc[i].name, m_udsInfo.dtc[i].dtc[3]));
				}
			}
		}

		if (!success)
		{
			setLastError("检测DTC失败");
			break;
		}
		result = true;
	} while (false);
	addListItem(Q_SPRINTF("检测DTC %s", OK_NG(result)), false);
	return result;
}

bool DetectionTool::checkCurrent()
{
	setCurrentStatus("检测电流");
	bool result = false, success = true;
	do
	{
		auto info = m_hwdInfo.current;
		for (int i = 0; i < MAX_ITEM_COUNT; i++)
		{
			if (!info[i].valid)
			{
				continue;
			}

			float voltage = 0.0f;
			if (!m_power.GetVoltage(&voltage))
			{
				success = false;
				LOG_OUTPUT("获取电压错误");
				break;
			}

			if (fabs(voltage - info[i].voltage) > 0.1)
			{
				if (!m_power.SetVol(info[i].voltage))
				{
					success = false;
					LOG_OUTPUT("设置电压错误");
					break;
				}
				msleep(3000);
			}

			if (!m_power.GetCurrent(&info[i].read))
			{
				success = false;
				LOG_OUTPUT("获取电流错误");
				break;
			}

			if ((info[i].read >= info[i].low) && (info[i].read <= info[i].high))
			{
				info[i].result = true;
			}
			else
			{
				info[i].result = false;
				success = false;
			}
			addListItem(Q_SPRINTF("%s  %.3f  %s", G_TO_C_STR(info[i].name), info[i].read, OK_NG(info[i].result)));
		}

		if (!success)
		{
			setLastError("检测电流失败");
			break;
		}

		result = true;
	} while (false);
	m_power.SetVol(m_hardwareConfig.powerVoltage);
	addListItem(Q_SPRINTF("检测电流 %s", OK_NG(result)), false);
	return result;
}

bool DetectionTool::checkStaticCurrent(const ulong& delay)
{
	setCurrentStatus("检测静态电流");
	bool result = false;
	do
	{
		addListItem("检测静态电流需要一定时间大约30秒,请耐心等待...");
		float current = 0.0f;
		if (!m_power.GetCurrent(&current))
		{
			LOG_OUTPUT("获取工作电流失败");
			break;
		}

		if (current < 0.1)
		{
			LOG_OUTPUT("系统未上电");
			break;
		}

		if (!m_relay.SetOneIO(m_relayConfig.acc, false))
		{
			LOG_OUTPUT("继电器关闭IG失败");
			break;
		}

		msleep(300);

		size_t startTime = GetTickCount();
		bool success = false;
		while (true)
		{
			if (m_power.GetCurrent(&current))
			{
				if (current < 0.01)
				{
					success = true;
					break;
				}
			}

			if (GetTickCount() - startTime >= 15000)
			{
				LOG_OUTPUT("系统休眠超时");
				break;
			}
			msleep(300);
		}

		if (!success)
		{
			break;
		}

		msleep(500);

		if (!m_relay.SetOneIO(m_relayConfig.staticCur, true))
		{
			LOG_OUTPUT("继电器静态电流表打开失败");
			break;
		}

		msleep(300);
		if (!m_relay.SetOneIO(m_relayConfig.gnd, false))
		{
			LOG_OUTPUT("继电器GND打开关闭失败");
			break;
		}

		msleep(delay);

		StaticCurrentMgr staticCurrent;

		auto const info = &m_hwdInfo.staticCurrent;
		if (!staticCurrent.Open(m_hardwareConfig.staticPort, m_hardwareConfig.staticBaud))
		{
			LOG_OUTPUT(G_TO_Q_STR(staticCurrent.GetLastError().c_str()));
			break;
		}

		if (!staticCurrent.GetStaticCurrent(info->read))
		{
			LOG_OUTPUT(G_TO_Q_STR(staticCurrent.GetLastError().c_str()));
			break;
		}
		staticCurrent.Close();

		info->result = ((info->read >= info->low) && (info->read < info->high));

		addListItem(Q_SPRINTF("静态电流  %.3f  %s", info->read, OK_NG(info->result)));

		if (!info->result)
		{
			break;
		}

		if (!m_relay.SetOneIO(m_relayConfig.gnd, true))
		{
			LOG_OUTPUT("继电器GND打开失败");
			break;
		}

		msleep(500);

		if (!m_relay.SetOneIO(m_relayConfig.staticCur, false))
		{
			LOG_OUTPUT("继电器静态电流表打开失败");
			break;
		}
		msleep(300);
		//if (!m_relay.SetOneIO(m_relayConfig.acc, true))
		//{
		//	LOG_OUTPUT("继电器ACC打开失败")
		//	break;
		//}
		//msleep(300);
		result = true;
	} while (false);
	addListItem(Q_SPRINTF("检测静态电流 %s", OK_NG(result)), false);
	return result;
}

bool DetectionTool::checkCanRouseSleep(const MsgNode& rouseMsg, const size_t& delay, LaunchProc launchProc, void* args)
{
	bool result = false, success = false;
	do
	{
		setCurrentStatus("检测CAN唤醒");
		m_canSender.AddMsg(rouseMsg, delay);
		m_canSender.Start();
		success = launchProc(args);
		m_canSender.DeleteOneMsg(rouseMsg.id);
		m_logData[LN_CAN_ROUSE] = LOG_INPUT("%s CAN唤醒", OK_NG(success));
		addListItemEx(Q_SPRINTF("CAN唤醒 %s", OK_NG(success)));
		LOG_ASSERT(success, "CAN唤醒失败");

		success = false;
		setCurrentStatus("检测CAN休眠");
		size_t startTime = GetTickCount();
		float current = 0.0f;
		while (true)
		{
			m_power.GetCurrent(&current);

			if (current <= m_thresholdConfig.canSleep)
			{
				success = true;
				break;
			}

			if (success || GetTickCount() - startTime >= 20000)
			{
				break;
			}
			msleep(300);
		}

		m_logData[LN_CAN_SLEEP] = LOG_INPUT("%s CAN休眠", OK_NG(success));
		addListItemEx(Q_SPRINTF("CAN休眠 %s", OK_NG(success)));
		LOG_ASSERT(success, "CAN休眠失败");
		m_relay.SetOneIO(m_relayConfig.acc, true);
		msleep(300);
		result = true;
	} while (false);
	return result;
}

bool DetectionTool::checkKeyVoltag()
{
	setCurrentStatus("检测按键电压");
	bool result = false, success = true;
	do
	{
		auto info = &m_hwdInfo.keyVol;
		if (!m_voltage.ReadVol(&info->lRead))
		{
			LOG_OUTPUT("读取电压表失败");
			break;
		}

		if ((info->lRead >= info->lLLimit) && (info->lRead <= info->lULimit))
		{
			info->lResult = true;
		}
		else
		{
			info->lResult = false;
			success = false;
		}

		addListItem(Q_SPRINTF("按键低电平  %.3f  %s", info->lRead, OK_NG(info->lResult)));

		tiggerAVMByKey();
		
		msleep(5000);

		if (!m_voltage.ReadVol(&info->hRead))
		{
			LOG_OUTPUT("读取电压表失败");
			break;
		}

		if ((info->hRead >= info->hLLimit) && (info->hRead <= info->hULimit))
		{
			info->hResult = true;
		}
		else
		{
			info->hResult = false;
			success = false;
		}
		addListItem(Q_SPRINTF("按键高电平  %.3f  %s", info->hRead, OK_NG(info->hResult)));

		if (!success)
		{
			setLastError("检测按键电压失败");
			break;
		}

		result = true;
	} while (false);
	addListItem(Q_SPRINTF("检测按键电压 %s", OK_NG(result)), false);
	return result;
}

bool DetectionTool::checkVoltage()
{
	setCurrentStatus("检测电压");
	bool result = false, success = true;
	do
	{
		auto info = m_hwdInfo.voltage;

		for (int i = 0; i < MAX_ITEM_COUNT; i++)
		{
			if (!info[i].valid)
			{
				continue;
			}

			if (!m_relay.SetOneIO(info[i].relay, true))
			{
				LOG_OUTPUT("打开继电器失败");
				success = false;
				break;
			}

			msleep(1200);

			if (!m_voltage.ReadVol(&info[i].read))
			{
				LOG_OUTPUT("电压表读取失败");
				success = false;
			}
			else
			{
				if ((info[i].read >= info[i].low) && (info[i].read < info[i].high))
				{
					info[i].result = true;
				}
				else
				{
					success = false;
					info[i].result = false;
					LOG_OUTPUT(Q_SPRINTF("%s(%.3f):超出设定范围[%.3f-%.3f]", 
						G_TO_C_STR(info[i].name), info[i].read, info[i].low, info[i].high));
				}
			}

			addListItem(Q_SPRINTF("%s  %.3f  %s", G_TO_C_STR(info[i].name), info[i].read, OK_NG(info[i].result)));

			if (!m_relay.SetOneIO(info[i].relay, false))
			{
				success = false;
				LOG_OUTPUT("关闭继电器失败");
				break;
			}
			msleep(300);
		}

		if (!success)
		{
			setLastError("检测电压失败");
			break;
		}
		result = true;
	} while (false);
	addListItem(Q_SPRINTF("检测电压 %s", OK_NG(result)), false);
	return result;
}

bool DetectionTool::clearDtc()
{
	setCurrentStatus("清除DTC");
	bool result = m_udsApplyMgr->ClearDiagnosticInformation();
	addListItemEx(Q_SPRINTF("清除DTC %s", OK_NG(result)));
	m_logData[LN_CLEAR_DTC] = LOG_INPUT("%s 清除DTC", OK_NG(result));
	if (!result)
	{
		setLastError("清除DTC失败");
	}
	return result;
}

void DetectionTool::setAccessLevel(const int& udsLevel)
{
	m_udsLevel = udsLevel;
}

void DetectionTool::setDiagnosticSession(const int& udsSession)
{
	m_udsSession = udsSession;
}

void DetectionTool::restoreAccessLevel()
{
	m_udsLevel = SAL_LEVEL1;
}

void DetectionTool::restoreDiagnosticSession()
{
	m_udsSession = 0x03;
}

bool DetectionTool::writeDataByDid(const uchar& did0, const uchar& did1, const int& size, const uchar* data)
{
	bool result = false;
	do
	{
		if (!m_udsApplyMgr->DiagnosticSessionControl(m_udsSession))
		{
			break;
		}

		if (!m_udsApplyMgr->SecurityAccess(m_udsLevel))
		{
			break;
		}

		if (!m_udsApplyMgr->WriteDataByIdentifier(did0, did1, size, data))
		{
			break;
		}

		if (!confirmDataByDid(did0, did1, size, data))
		{
			break;
		}
		result = true;
	} while (false);
	if (!result)
	{
		setLastError(G_TO_Q_STR(m_udsApplyMgr->GetLastError()));
	}
	return result;
}

bool DetectionTool::writeDataByDidEx(const uchar* routine, const uchar& did0, const uchar& did1, const int& size, const uchar* data)
{
	bool result = false;
	do
	{
		if (!m_udsApplyMgr->DiagnosticSessionControl(m_udsSession))
		{
			break;
		}

		if (!m_udsApplyMgr->SecurityAccess(m_udsLevel))
		{
			break;
		}

		uchar routineData = 0x01;
		if (!m_udsApplyMgr->RoutineControl(routine[0], routine[1], routine[2], 1, &routineData, 0, 0))
		{
			break;
		}

		if (!m_udsApplyMgr->WriteDataByIdentifier(did0, did1, size, data))
		{
			break;
		}

		if (!confirmDataByDid(did0, did1, size, data))
		{
			break;
		}
		result = true;
	} while (false);
	if (!result)
	{
		setLastError(G_TO_Q_STR(m_udsApplyMgr->GetLastError()));
	}
	return result;
}

bool DetectionTool::confirmDataByDid(const uchar& did0, const uchar& did1, const int& size, const uchar* data)
{
	bool result = false;
	do
	{
		int recvSize = 0;
		uchar buffer[256] = { 0 };
		if (!m_udsApplyMgr->ReadDataByIdentifier(did0, did1, &recvSize, buffer))
		{
			setLastError(G_TO_Q_STR(m_udsApplyMgr->GetLastError()));
			break;
		}

		if (size != recvSize)
		{
			setLastError("读取长度对比失败");
			break;
		}

		if (memcmp(data, buffer, size))
		{
			setLastError("对比数据失败");
			break;
		}
		result = true;
	} while (false);
	return result;
}

bool DetectionTool::writeDefaultLog(QFile& file, bool success)
{
	bool result = false;
	do
	{
		file.setFileName(createLogFile(success));
		if (!file.open(QIODevice::WriteOnly))
		{
			setLastError("打开文件失败" + file.errorString());
			break;
		}

		QTextStream stream(&file);
		stream << Q_SPRINTF(" ,条形码,%s,\n,检测结果,%s,\n", Q_TO_C_STR(g_code), OK_NG(success));

		/*电源*/
		if (m_enableLogType[LT_VOL])
		{
			auto voltageInfo = m_hwdInfo.voltage;
			for (int i = 0; i < MAX_ITEM_COUNT; i++)
			{
				if (!voltageInfo[i].valid)
					continue;
				stream << Q_SPRINTF("%s,%s,%.3f,%.3f,%.3f\n", OK_NG(voltageInfo[i].result), G_TO_C_STR(voltageInfo[i].name),
					voltageInfo[i].read, voltageInfo[i].high, voltageInfo[i].low);
			}
		}

		/*电阻*/
		if (m_enableLogType[LT_RES])
		{
			auto resInfo = m_hwdInfo.res;
			for (int i = 0; i < MAX_ITEM_COUNT; i++)
			{
				if (!resInfo[i].valid)
					continue;
				stream << Q_SPRINTF("%s,%s,%.3f,%.3f,%.3f\n", OK_NG(resInfo[i].result), G_TO_C_STR(resInfo[i].name),
					resInfo[i].read, resInfo[i].high, resInfo[i].low);
			}
		}

		/*电流*/
		if (m_enableLogType[LT_CUR])
		{
			auto currentInfo = m_hwdInfo.current;
			for (int i = 0; i < MAX_ITEM_COUNT; i++)
			{
				if (!currentInfo[i].valid)
					continue;
				stream << Q_SPRINTF("%s,%s,%.3f,%.3f,%.3f\n", OK_NG(currentInfo[i].result), G_TO_C_STR(currentInfo[i].name),
					currentInfo[i].read, currentInfo[i].high, currentInfo[i].low);
			}
		}

		/*静态电流*/
		if (m_enableLogType[LT_SCUR])
		{
			auto staticInfo = m_hwdInfo.staticCurrent;
			stream << Q_SPRINTF("%s,静态电流,%.3f,%.3f,%.3f\n", OK_NG(staticInfo.result), staticInfo.read,
				staticInfo.high, staticInfo.low);
		}

		/*LED电压*/
		if (m_enableLogType[LT_KEY])
		{
			auto keyVolInfo = m_hwdInfo.keyVol;
			stream << Q_SPRINTF("%s,按键电压,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f\n",
				OK_NG(keyVolInfo.lResult && keyVolInfo.hResult), keyVolInfo.lRead, keyVolInfo.lULimit,
				keyVolInfo.lLLimit, keyVolInfo.hRead, keyVolInfo.hULimit, keyVolInfo.hLLimit);
		}

		/*版本号*/
		if (m_enableLogType[LT_VER])
		{
			for (int i = 0; i < MAX_VERSION_COUNT; i++)
			{
				if (!m_udsInfo.ver[i].valid)
					continue;
				stream << Q_SPRINTF("%s,%s,%s,%s\n", OK_NG(m_udsInfo.ver[i].result), G_TO_C_STR(m_udsInfo.ver[i].name),
					G_TO_C_STR(m_udsInfo.ver[i].read), G_TO_C_STR(m_udsInfo.ver[i].setup));
			}
		}

		/*故障码*/
		if (m_enableLogType[LT_DTC])
		{
			for (int i = 0; i < MAX_DTC_COUNT; i++)
			{
				if (!m_udsInfo.dtc[i].valid || !m_udsInfo.dtc[i].exist)
					continue;
				stream << Q_SPRINTF("%s,%s\n", "NG", G_TO_Q_STR(m_udsInfo.dtc[i].name));
			}
		}
		result = true;
	} while (false);
	return result;
}

void DetectionTool::initBaseDl()
{

	for (size_t i = 0; i < m_jsonTool->getCurrentConfigCount(); i++)
	{
		m_hwdInfo.current[i].read = 0.0f;
		m_hwdInfo.current[i].result = false;
	}

	for (size_t i = 0; i < m_jsonTool->getResConfigCount(); i++)
	{
		m_hwdInfo.res[i].read = 0.0f;
		m_hwdInfo.res[i].result = false;
	}

	for (size_t i = 0; i < m_jsonTool->getVoltageConfigCount(); i++)
	{
		m_hwdInfo.voltage[i].read = 0.0f;
		m_hwdInfo.voltage[i].result = false;
	}

	for (size_t i = 0; i < MAX_VERSION_COUNT; i++)
	{
		if (m_udsInfo.ver[i].valid)
		{
			m_udsInfo.ver[i].result = false;
			memset(m_udsInfo.ver[i].read, 0x00, sizeof(m_udsInfo.ver[i].read));
		}
	}

	for (size_t i = 0; i < MAX_DTC_COUNT; i++)
	{
		if (m_udsInfo.dtc[i].valid)
		{
			m_udsInfo.dtc[i].exist = false;
		}
	}

	for (size_t i = 0; i < sizeof(m_logData) / sizeof(QString); i++)
	{
		m_logData[i] = "NG,";
	}
}

void DetectionTool::setWriteBaseDl(std::initializer_list<LogType> logType)
{
	const int logArray[] = { LT_VOL,LT_RES,LT_CUR,LT_SCUR,LT_KEY,LT_VER,LT_DTC };
	for (int i = 0; i < sizeof(logArray) / sizeof(int); i++)
	{
		m_enableLogType.insert(logArray[i], false);
	}

	for (int i = 0; i < logType.size(); i++)
	{
		for (int j = 0; j < sizeof(logArray) / sizeof(int); j++)
		{
			if (logArray[j] == logType.begin()[i])
			{
				m_enableLogType[j] = true;
			}
		}
	}
}

const QString DetectionTool::createLogFile(bool success)
{
	QString result = "";
	do
	{
		QDir dir;
		QString logDirName = m_deviceConfig.detectionName == "功能" ? "FcLog" : "HwLog";
		/*log/error/20200228/机种_条码_时分秒.csv*/
		QString filePath = QString("./%1/%2/%3/").arg(logDirName, success ? "NOR" : "ERR", getCurrentDate(true));
		if (!dir.exists(filePath))
		{
			if (!dir.mkpath(filePath))
			{
				setLastError("创建日志路径失败");
				break;
			}
		}
		result = filePath.append(QString("%1_%2_%3.csv")
			.arg(m_deviceConfig.modelName, g_code.isEmpty() ? "未知条码" : g_code, getCurrentTime(true)));
	} while (false);
	return result;
}

const QString& DetectionTool::getLastError()
{
	return m_lastError;
}

bool DetectionTool::enterSecurityAccess(const uchar& session, const uchar& access)
{
	bool result = false;
	do
	{
		m_canConnMgr->ClearRecBuffer();
		if (!m_udsApplyMgr->SafeDiagnosticSessionControl(session))
		{
			setLastError(QString("进入扩展模式失败,原因%1.").arg(G_TO_Q_STR(m_udsApplyMgr->GetLastError())));
			break;
		}

		if (!m_udsApplyMgr->SafeSecurityAccess(access))
		{
			setLastError(QString("安全解锁失败,原因%1.").arg(G_TO_Q_STR(m_udsApplyMgr->GetLastError())));
			break;
		}
		result = true;
	} while (false);
	return result;
}

bool DetectionTool::addCanMsg(const MsgNode& msg, const int& cycle, const SendType& sendType, const int& count)
{
	return m_canSender.AddMsg(msg, cycle, sendType, count);
}

bool DetectionTool::addCanMsg(const CanMsg& msg)
{
	return m_canSender.AddMsg(msg);
}

bool DetectionTool::delCanMsg(const int& id)
{
	return m_canSender.DeleteOneMsg(id);
}

bool DetectionTool::delCanMsgs(std::initializer_list<int> ids)
{
	return  m_canSender.DeleteMsgs(ids);
}

bool DetectionTool::delCanMsgs(const int* ids, const int& count)
{
	return m_canSender.DeleteMsgs(ids, count);
}

bool DetectionTool::sendCanMsg()
{
	return m_canSender.Start();
}

bool DetectionTool::stopCanMsg()
{
	return m_canSender.Stop();
}

void DetectionTool::threadPause()
{
	g_threadWait = true;
	while (g_threadWait) { msleep(100); }
}

bool DetectionTool::threadIsPause()
{
	return g_threadWait;
}

void DetectionTool::threadContinue()
{
	g_threadWait = false;
}

void DetectionTool::threadQuit()
{
	m_connect = false;
	m_quit = true;

	if (threadIsPause())
	{
		closeDevice();
		threadContinue();
	}

	if (isRunning())
	{
		wait(5000);
	}

	quit();
}

void DetectionTool::setScanCodeDlg(bool show)
{
	emit setScanCodeDlgSignal(show);
	show ? threadPause() : threadContinue();
}

void DetectionTool::setUnlockDlg(bool show)
{
	emit setUnlockDlgSignal(show);
	threadPause();
}

void DetectionTool::setMessageBox(const QString& title, const QString& text)
{
	emit setMessageBoxSignal(title, text);
	threadPause();
}

void DetectionTool::setMessageBoxEx(const QString& title, const QString& text, const QPoint& point)
{
	emit setMessageBoxExSignal(title, text, point);
	threadPause();
}

bool DetectionTool::setQuestionBox(const QString& title, const QString& text)
{
	bool result = false;
	emit setQuestionBoxSignal(title, text, &result);
	threadPause();
	return result;
}

bool DetectionTool::setQuestionBoxEx(const QString& title, const QString& text, const QPoint& point)
{
	bool result = false;
	emit setQuestionBoxExSignal(title, text, &result, point);
	threadPause();
	return result;
}

void DetectionTool::setTestResult(const testResult_t& testResult)
{
	emit setTestResultSignal(testResult);
}

void DetectionTool::setCurrentStatus(const QString& status, bool systemStatus)
{
	emit setCurrentStatusSignal(status, systemStatus);
}

void DetectionTool::addListItem(const QString& item, bool logItem)
{
	emit addListItemSignal(QString("%1 %2").arg(getCurrentTime(), item), logItem);
}

void DetectionTool::addListItemEx(const QString& item)
{
	addListItem(item, false); addListItem(item, true);
}

void DetectionTool::clearListItem()
{
	emit clearListItemSignal();
}

const QString DetectionTool::getCurrentTime(bool fileFormat)
{
	return fileFormat ? QTime::currentTime().toString("hh:mm:ss").remove(':')
		: QTime::currentTime().toString("hh:mm:ss.zzz");
}

const QString DetectionTool::getCurrentDate(bool fileFormat)
{
	return fileFormat ? QDate::currentDate().toString("yyyy-MM-dd").remove('-')
		: QDate::currentDate().toString("yyyy-MM-dd");
}

const QString DetectionTool::getCurrentDateTime(bool fileFormat)
{
	QString dateTime = QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss.zzz");
	if (fileFormat)
	{
		//return dateTime.replace(":", "-").replace(".", "-");
		return dateTime.remove('-').remove(':').remove('.');
	}
	return dateTime;
}

void DetectionTool::drawRectOnImage(IplImage* cvImage)
{
	if (m_rectType == "BIG")
	{
		cvRectangle(cvImage, cvPoint(m_imageCheckConfig.bigRect->startX, m_imageCheckConfig.bigRect->startY),
			cvPoint(m_imageCheckConfig.bigRect->startX + m_imageCheckConfig.bigRect->width,
				m_imageCheckConfig.bigRect->startY + m_imageCheckConfig.bigRect->height), CV_RGB(255, 0, 0), 2);
	}
	else if (m_rectType == "SMALL")
	{
		for (int i = 0; i < 4; i++)
		{
			cvRectangle(cvImage, cvPoint(m_imageCheckConfig.smallRect[i].startX, m_imageCheckConfig.smallRect[i].startY),
				cvPoint(m_imageCheckConfig.smallRect[i].startX + m_imageCheckConfig.smallRect[i].width,
					m_imageCheckConfig.smallRect[i].startY + m_imageCheckConfig.smallRect[i].height), CV_RGB(0, 255, 0), 2);
		}
	}

	return;
}

bool DetectionTool::checkRectOnImage(IplImage* cvImage, const rectConfig_t& rectParam, QString& colorData)
{
	bool result = false;
	do
	{
		cvSetImageROI(cvImage, cvRect(rectParam.startX, rectParam.startY, rectParam.width, rectParam.height));
		Mat matHsv;
		cvtColor(cvarrToMat(cvImage), matHsv, COLOR_BGR2HSV);

		std::vector<int> colorVec;
		colorVec.push_back(matHsv.at<uchar>(0, 0));
		colorVec.push_back(matHsv.at<uchar>(0, 1));
		colorVec.push_back(matHsv.at<uchar>(0, 2));

		int limit = 0, upper = 0;
		bool success = true;
		int rgb[3] = { rectParam.red,rectParam.green,rectParam.blue };
		for (int i = 0; i < 3; i++)
		{
			limit = rgb[i] - rectParam.deviation;
			upper = rgb[i] + rectParam.deviation;
			if (!((colorVec[abs(i - 2)] >= limit) && (colorVec[abs(i - 2)] <= upper)))
			{
				success = false;
			}
		}

		char color[32] = { 0 };
		if ((colorVec[0] >= 0 && colorVec[0] <= 180)
			&& (colorVec[1] >= 0 && colorVec[1] <= 255)
			&& (colorVec[2] >= 0 && colorVec[2] <= 46))
		{
			strcpy(color, "黑色");
		}
		else if ((colorVec[0] >= 0 && colorVec[0] <= 180)
			&& (colorVec[1] >= 0 && colorVec[1] <= 43)
			&& (colorVec[2] >= 46 && colorVec[2] <= 220))
		{
			strcpy(color, "灰色");
		}
		else if ((colorVec[0] >= 0 && colorVec[0] <= 180)
			&& (colorVec[1] >= 0 && colorVec[1] <= 30)
			&& (colorVec[2] >= 221 && colorVec[2] <= 255))
		{
			strcpy(color, "白色");
		}
		else if (((colorVec[0] >= 0 && colorVec[0] <= 10)
			|| (colorVec[0] >= 156 && colorVec[0] <= 180))
			&& (colorVec[1] >= 43 && colorVec[1] <= 255)
			&& (colorVec[2] >= 46 && colorVec[2] <= 255))
		{
			strcpy(color, "红色");;
		}
		else if ((colorVec[0] >= 11 && colorVec[0] <= 25)
			&& (colorVec[1] >= 43 && colorVec[1] <= 255)
			&& (colorVec[2] >= 46 && colorVec[2] <= 255))
		{
			strcpy(color, "橙色");
		}
		else if ((colorVec[0] >= 26 && colorVec[0] <= 34)
			&& (colorVec[1] >= 43 && colorVec[1] <= 255)
			&& (colorVec[2] >= 46 && colorVec[2] <= 255))
		{
			strcpy(color, "黄色");
		}
		else if ((colorVec[0] >= 35 && colorVec[0] <= 77)
			&& (colorVec[1] >= 43 && colorVec[1] <= 255)
			&& (colorVec[2] >= 46 && colorVec[2] <= 255))
		{
			strcpy(color, "绿色");
		}
		else if ((colorVec[0] >= 78 && colorVec[0] <= 99)
			&& (colorVec[1] >= 43 && colorVec[1] <= 255)
			&& (colorVec[2] >= 46 && colorVec[2] <= 255))
		{
			strcpy(color, "青色");
		}
		else if ((colorVec[0] >= 100 && colorVec[0] <= 124)
			&& (colorVec[1] >= 43 && colorVec[1] <= 255)
			&& (colorVec[2] >= 46 && colorVec[2] <= 255))
		{
			strcpy(color, "蓝色");
		}
		else if ((colorVec[0] >= 125 && colorVec[0] <= 155)
			&& (colorVec[1] >= 43 && colorVec[1] <= 255)
			&& (colorVec[2] >= 46 && colorVec[2] <= 255))
		{
			strcpy(color, "紫色");
		}
		else
		{
			strcpy(color, "未知颜色");
		}

		if (!success)
		{
			colorData.sprintf("RGB[%d,%d,%d]超出阈值 NG,分析所得颜色[%s]",
				colorVec[2], colorVec[1], colorVec[0], color);
			break;
		}
		else
		{
			colorData.sprintf("RGB[%d,%d,%d]正常范围 OK,分析所得颜色[%s]",
				colorVec[2], colorVec[1], colorVec[0], color);
		}
		result = true;
	} while (false);
	return result;
}

void DetectionTool::setRectType(const QString& rectType)
{
	m_rectType = rectType;
}

void DetectionTool::restoreRectType()
{
	m_rectType.clear();
}

void DetectionTool::setCaptureCardAttribute(const QString& cardName)
{
	m_captureCard.cardName = cardName;
	m_captureCard.width = (cardName == "MV800") ? 720 : 640;
	m_captureCard.height = 480;
	m_captureCard.size = m_captureCard.width * m_captureCard.height;
}

void DetectionTool::startCaptureCard()
{
	if (m_deviceConfig.captureName == "MV800")
	{
		m_mv800Mgr.StartCapture();
	}
	else
	{
		m_milCaptureThread->startCapture();
	}
}

void DetectionTool::endCaptureCard()
{
	if (m_deviceConfig.captureName == "MV800")
	{
		m_mv800Mgr.EndCapture();
	}
	else
	{
		m_milCaptureThread->endCapture();
	}
}

void DetectionTool::updateImage(const QImage& image)
{
	emit updateImageSignal(image);
}

bool DetectionTool::cvImageToQtImage(IplImage* cv, QImage* qt)
{
	bool result = false;
	do
	{
		if (!cv || !qt)
		{
			break;
		}
		cvCvtColor(cv, cv, CV_BGR2RGB);
		*qt = QImage((uchar*)cv->imageData, cv->width, cv->height, cv->widthStep, QImage::Format_RGB888);
		result = true;
	} while (false);
	return result;
}

bool DetectionTool::cycleCapture()
{
	bool result = false, success = true;
	do
	{
		m_capture = true;
		int count = 0;
		while (m_capture)
		{
			msleep(100);
			count++;
			if (count > 50)
			{
				success = false;
				break;
			}
		}

		if (!success)
		{
			setLastError("抓图失败");
			break;
		}
		result = true;
	} while (false);
	return result;
}

void DetectionTool::tiggerAVMByKey()
{
	m_relay.SetOneIO(m_relayConfig.key, true);
	msleep(300);
	m_relay.SetOneIO(m_relayConfig.key, false);
	msleep(300);
}

void DetectionTool::setLedLight(bool _switch)
{
	m_relay.SetOneIO(m_relayConfig.led, _switch);
	msleep(300);
}

bool DetectionTool::checkAVMUseMsg(const MsgNode& msg, const size_t& delay, bool(*judgeProc)(void*), void* args)
{
	bool result = false, success = true;
	do
	{
		m_canSender.AddMsg(msg, delay, ST_Event, 3);
		m_canSender.Start();
		msleep(delay * 2);

		if (!judgeProc(args))
		{
			setLastError("按键进入全景失败");
			break;
		}

		msleep(2000);

		if (!cycleCapture())
		{
			break;
		}

		const char* name[] = { "前","后","左","右" };
		QString colorData;
		for (size_t i = 0; i < 4; i++)
		{
			if (!checkRectOnImage(m_cvAnalyze, m_imageCheckConfig.smallRect[i], colorData))
			{
				success = false;
			}
			addListItem(QString("%1摄像头,%2").arg(name[i], colorData));
			msleep(1000);
		}

		if (!success)
		{
			break;
		}
		result = true;
	} while (false);
	return result;
}

bool DetectionTool::checkAVMUseKey(LaunchProc lanunchProc, RequestProc requestProc, const int& request, void* args, const ulong& delay)
{
	setCurrentStatus("检测AVM视频");
	bool result = false, success = true;
	do
	{
		if (!lanunchProc(args))
		{
			setLastError("启动失败");
			break;
		}

		if (delay)
		{
			msleep(delay);
		}

		/*此处增加检测按键电压*/
		auto info = &m_hwdInfo.keyVol;
		if (!m_voltage.ReadVol(&info->lRead))
		{
			LOG_OUTPUT("读取电压表失败");
			break;
		}

		if ((info->lRead >= info->lLLimit) && (info->lRead <= info->lULimit))
		{
			info->lResult = true;
		}
		else
		{
			info->lResult = false;
			success = false;
		}

		addListItem(Q_SPRINTF("按键低电平  %.3f  %s", info->lRead, OK_NG(info->lResult)));

		tiggerAVMByKey();

		if (!requestProc(request, args))
		{
			setLastError("按键进入全景失败");
			break;
		}

		setRectType("SMALL");
		msleep(3000);

		if (!m_voltage.ReadVol(&info->hRead))
		{
			LOG_OUTPUT("读取电压表失败");
			break;
		}

		if ((info->hRead >= info->hLLimit) && (info->hRead <= info->hULimit))
		{
			info->hResult = true;
		}
		else
		{
			info->hResult = false;
			success = false;
		}
		addListItem(Q_SPRINTF("按键高电平  %.3f  %s", info->hRead, OK_NG(info->hResult)));

		LOG_ASSERT(success, "检测按键电压失败");

		success = true;

		if (!cycleCapture())
		{
			break;
		}

		const char* name[] = { "前","后","左","右" };
		QString colorData;
		for (size_t i = 0; i < 4; i++)
		{
			if (!checkRectOnImage(m_cvAnalyze, m_imageCheckConfig.smallRect[i], colorData))
			{
				success = false;
			}
			addListItem(QString("%1摄像头小图,%2").arg(name[i], colorData));
			msleep(1000);
		}
		LOG_ASSERT(success, "检测AVM视频失败");
		result = true;
	} while (false);
	restoreRectType();
	m_logData[LN_AVM_VIDEO] = LOG_INPUT("%s 检测AVM视频", OK_NG(result));
	addListItem(Q_SPRINTF("检测AVM视频 %s", OK_NG(result)), false);
	return result;
}

bool DetectionTool::checkAVMFRView(std::initializer_list<MsgNode> msg, const size_t& delay)
{
	setCurrentStatus("检测前后视图");
	bool result = false, success = true;
	do
	{
		/*前景*/
		const char* name[] = { "前","后","左","右" };
		QString colorData;
		for (int i = 0; i < msg.size(); i++)
		{
			m_canSender.AddMsg(msg.begin()[i], delay);
			setRectType("BIG");
			msleep(3000);

			if (!cycleCapture())
			{
				break;
			}

			if (!checkRectOnImage(m_cvAnalyze, m_imageCheckConfig.bigRect[abs(i - 1)], colorData))
			{
				success = false;
			}
			addListItem(QString("%1摄像头大图,%2").arg(name[abs(i - 1)], colorData));
			m_canSender.DeleteOneMsg(msg.begin()[i].id);
		}
		msleep(1000);
		result = true;
	} while (false);
	restoreRectType();
	m_logData[LN_FR_VIEW] = LOG_INPUT("%s 检测前后视图", OK_NG(result));
	addListItem(Q_SPRINTF("检测前后视图 %s", OK_NG(result)), false);
	return result;
}

void DetectionTool::setDvrNetworkType(const DvrNetworkType& networkType)
{
	m_dvrNetworkType = networkType;
}

void DetectionTool::setVlcMediaHwnd(HWND vlcHwnd)
{
	m_vlcHwnd = vlcHwnd;
}

bool DetectionTool::vlcRtspStart(const QString& url)
{
	bool result = false;
	do
	{
		if (url.isEmpty())
		{
			setLastError("rtsp协议地址为空");
			break;
		}

		const char* const vlcArgs[] = {
			//"--rtsp-frame-buffer-size=1000000",
			"--ipv4",
			"--no-prefer-system-codecs",
			"--rtsp-caching=300",
			"--network-caching=500",
			"--rtsp-tcp"
		};

		if (!m_vlcInstance)
		{
			m_vlcInstance = libvlc_new(sizeof(vlcArgs) / sizeof(*vlcArgs), vlcArgs);
			if (!m_vlcInstance)
			{
				setLastError("创建vlc实例失败,请确认文件内是否包含\n[lua ,plugins ,libvlc.dll ,libvlccore.dll]");
				break;
			}
		}

		if (!m_vlcMedia)
		{
			m_vlcMedia = libvlc_media_new_location(m_vlcInstance, url.toStdString().c_str());
			if (!m_vlcMedia)
			{
				setLastError("创建vlc媒体失败");
				break;
			}
		}

		if (!m_vlcMediaPlayer)
		{
			m_vlcMediaPlayer = libvlc_media_player_new_from_media(m_vlcMedia);
			if (!m_vlcMediaPlayer)
			{
				setLastError("创建vlc媒体播放器失败");
				break;
			}
		}

		if (!m_vlcHwnd)
		{
			setLastError("请调用setVlcMediaHwnd设置播放控件句柄");
			break;
		}

		libvlc_media_player_set_hwnd(m_vlcMediaPlayer, m_vlcHwnd);

		int value = libvlc_media_player_play(m_vlcMediaPlayer);
		if (value == -1)
		{
			setLastError("vlc媒体播放器播放视频失败");
			break;
		}
		result = true;
	} while (false);
	return result;
}

bool DetectionTool::vlcRtspStop()
{
	bool result = false;
	do
	{
		if (m_vlcInstance)
		{
			libvlc_release(m_vlcInstance);
			m_vlcInstance = nullptr;
		}

		if (m_vlcMedia)
		{
			libvlc_media_release(m_vlcMedia);
			m_vlcMedia = nullptr;
		}

		if (m_vlcMediaPlayer)
		{
			libvlc_media_player_stop(m_vlcMediaPlayer);
			libvlc_media_player_release(m_vlcMediaPlayer);
			m_vlcMediaPlayer = nullptr;
		}
		result = true;
	} while (false);
	return result;
}

const size_t DetectionTool::dvrCrc32Algorithom(uchar const* memoryAddr, const size_t& memoryLen, const size_t& oldCrc32)
{
	static const size_t crc32tbl[256] =
	{
		0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,
		0x9E6495A3,0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,
		0xE7B82D07,0x90BF1D91,0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,
		0x6DDDE4EB,0xF4D4B551,0x83D385C7,0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,
		0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,0x3B6E20C8,0x4C69105E,0xD56041E4,
		0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,0x35B5A8FA,0x42B2986C,
		0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,0x26D930AC,
		0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,
		0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,
		0xB6662D3D,0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,
		0x9FBFE4A5,0xE8B8D433,0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,
		0x086D3D2D,0x91646C97,0xE6635C01,0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,
		0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,0x65B0D9C6,0x12B7E950,0x8BBEB8EA,
		0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,0x4DB26158,0x3AB551CE,
		0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,0x4369E96A,
		0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
		0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,
		0xCE61E49F,0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,
		0xB7BD5C3B,0xC0BA6CAD,0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,
		0x9DD277AF,0x04DB2615,0x73DC1683,0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,
		0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,0xF00F9344,0x8708A3D2,0x1E01F268,
		0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,0xFED41B76,0x89D32BE0,
		0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,0xD6D6A3E8,
		0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,
		0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,
		0x4669BE79,0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,
		0x220216B9,0x5505262F,0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,
		0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,
		0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,0x95BF4A82,0xE2B87A14,0x7BB12BAE,
		0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,0x86D3D2D4,0xF1D4E242,
		0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,0x88085AE6,
		0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
		0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,
		0x3E6E77DB,0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,
		0x47B2CF7F,0x30B5FFE9,0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,
		0xCDD70693,0x54DE5729,0x23D967BF,0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,
		0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D
	};

	size_t oldcrc32 = oldCrc32, length = memoryLen, crc32, oldcrc;
	uchar ccc, t;

	while (length--)
	{
		t = (uchar)(oldcrc32 >> 24U) & 0xFFU;
		oldcrc = crc32tbl[t];
		ccc = *memoryAddr;
		oldcrc32 = (oldcrc32 << 8U | ccc);
		oldcrc32 = oldcrc32 ^ oldcrc;
		memoryAddr++;
	}
	crc32 = oldcrc32;
	return crc32;
}

bool DetectionTool::getDvrFileUrl(QString& url, const dvrFileType_t& fileType, const char* ipAddr, const ushort port, const int protocol)
{
	bool result = false;
	do
	{
		const size_t sendLen = 0x10;
		const size_t recvLen = BUFF_SIZE;
		if (!m_dvrClient.connectServer(ipAddr, port, protocol))
		{
			LOG_OUTPUT("连接到服务器失败");
			break;
		}

		/*						    0	 1	  2    3    4    5    6    7    8    9   10   11*/
		char sendData[sendLen] = { 0xEE,0xAA,0x06,0x00,0x00,0x00,0x10,0x02,(char)fileType,(char)fileType,0x01,0x01 };
		size_t crc32 = dvrCrc32Algorithom((uchar*)&sendData[2], 10, 0);
		sendData[12] = crc32 & 0xff;
		sendData[13] = (crc32 >> 8) & 0xff;
		sendData[14] = (crc32 >> 16) & 0xff;
		sendData[15] = (crc32 >> 24) & 0xff;

#ifdef QT_DEBUG
		qDebug() << getCurrentTime() << "开始发送" << endl;
		for (size_t i = 0; i < sendLen; i++)
		{
			printf("[%u:%x]\n", i, sendData[i]);
		}
		qDebug() << getCurrentTime() << "发送结束" << endl;
#endif

		if (m_dvrClient.send(sendData, sendLen) == -1)
		{
			LOG_OUTPUT("发送失败");
			break;
		}

		char recvData[recvLen] = { 0 };

		/*避免心跳包*/
		bool success = true;
		size_t startTime = GetTickCount();
		while (!((recvData[6] == 0x10) && (recvData[7] == 0x02)))
		{
			memset(recvData, 0x00, recvLen);
			if (m_dvrClient.recv(recvData, recvLen) == -1)
			{
				success = false;
				LOG_OUTPUT("接收失败");
				break;
			}

			if (GetTickCount() - startTime >= 10000)
			{
				success = false;
				break;
			}
		}

		if (!success)
		{
			LOG_OUTPUT("未接收到文件列表数据包");
			break;
		}

#ifdef QT_DEBUG
		qDebug() << getCurrentTime() << "开始接收" << endl;
		size_t count;
		memcpy(&count, &recvData[2], sizeof(count));
		for (size_t i = 0; i < count; i++)
		{
			printf("[%u:%x]\n", i, recvData[i]);
		}
		qDebug() << getCurrentTime() << "接收结束" << endl;
#endif

		if ((uchar)recvData[0] != 0xEE || (uchar)(recvData[1]) != 0xAA)
		{
			LOG_OUTPUT("网络传输接收DVR数据错误");
			break;
		}

		dvrFileList_t dvrFileList;
		memset(&dvrFileList, 0x00, sizeof(dvrFileList_t));
		memcpy(&dvrFileList.listCount, &recvData[8], sizeof(size_t));

#ifdef QT_DEBUG
		qDebug() << "文件列表数量:" << dvrFileList.listCount << endl;
#endif

		dvrFileList.listCount = dvrFileList.listCount > 100 ? 100 : dvrFileList.listCount;

		char* pointer = &recvData[12];
		const char* dvrPath[] = { "NOR/", "EVT/", "PHO/" };
		const char* dvrType[] = { "NOR_", "EVT_", "PHO_", "_D1_" };
		const char* dvrSuffix[] = { ".mp4", ".jpg" };

		int maxDate = 0, flag = 0;

		for (int i = 0; i < dvrFileList.listCount; i++)
		{
			memcpy(&dvrFileList.dvrFileInfo[i].index, pointer, 2);
			pointer += 2;
			memcpy(&dvrFileList.dvrFileInfo[i].path, pointer, 1);
			pointer++;
			memcpy(&dvrFileList.dvrFileInfo[i].type, pointer, 1);
			pointer++;
			memcpy(&dvrFileList.dvrFileInfo[i].suffix, pointer, 1);
			pointer += 4;
			memcpy(&dvrFileList.dvrFileInfo[i].size, pointer, 4);
			pointer += 4;
			memcpy(&dvrFileList.dvrFileInfo[i].date, pointer, 4);
			pointer += 4;

			if (dvrFileList.dvrFileInfo[i].date >= maxDate)
			{
				maxDate = dvrFileList.dvrFileInfo[i].date;
				flag = i;
			}
		}

		int pathId = dvrFileList.dvrFileInfo[flag].path;
		int typeId = dvrFileList.dvrFileInfo[flag].type;

		if ((pathId < 0 || pathId > 2) || (typeId < 0 || typeId > 3))
		{
			LOG_OUTPUT("获取DVR文件列表数据包异常,\n请检测网络连接是否有波动");
			break;
		}

		url.sprintf("http://%s:%d/%s%s", ipAddr, 8080, dvrPath[pathId], dvrType[typeId]);
		/*此处要减去时差*/
		time_t dvrSecond = dvrFileList.dvrFileInfo[flag].date - 8 * 60 * 60;

		/*通过localtime将秒数转换为 年 月 日 时 分 秒*/
		struct tm* dvrDate = localtime(&dvrSecond);
		if (!dvrDate)
		{
			LOG_OUTPUT("localtime触发一个nullptr异常");
			break;
		}

		url.append(Q_SPRINTF("%04d%02d%02d_%02d%02d%02d_%05d",
			dvrDate->tm_year + 1900,
			dvrDate->tm_mon + 1,
			dvrDate->tm_mday,
			dvrDate->tm_hour,
			dvrDate->tm_min,
			dvrDate->tm_sec,
			dvrFileList.dvrFileInfo[flag].index));
		url.append(dvrSuffix[dvrFileList.dvrFileInfo[flag].suffix]);
		result = true;
	} while (false);
	m_dvrClient.closeConnect();
	return result;
}

bool DetectionTool::downloadDvrFile(const QString& url, const QString& dirName, bool downloadVideo)
{
	bool result = false;
	float networkSpeed = 0.0;
	do
	{
		QString path = QString("%1/%2/%3").arg(getCurrentDir(), dirName, getCurrentDate());
		if (!QDir(path).exists())
		{
			QDir dir;
			dir.mkpath(path);
		}

		QString destFile = path + url.mid(url.lastIndexOf("/"));
		size_t startDownloadTime = GetTickCount();
		HRESULT downloadResult = URLDownloadToFileA(NULL, Q_TO_C_STR(url), Q_TO_C_STR(destFile), NULL, NULL);
		float endDownloadTime = (GetTickCount() - startDownloadTime) / 1000.0f;

		if (downloadResult == S_OK)
		{
			struct _stat64i32 stat;
			_stat64i32(Q_TO_C_STR(destFile), &stat);
			float fileSize = stat.st_size / 1024.0f / 1024.0f;
			QString downloadInfo = Q_SPRINTF("文件大小:%.2fM,下载用时:%.2f秒,平均速度:%.2fM/秒",
				fileSize, endDownloadTime, fileSize / endDownloadTime);
			/*视频下载需要做网速处理*/
			if (downloadVideo)
			{
				networkSpeed = fileSize / endDownloadTime;
				if (networkSpeed >= m_rangeConfig.minNetworkSpeed && networkSpeed <= m_rangeConfig.maxNetworkSpeed)
				{
					result = true;
				}
				downloadInfo.append(Q_SPRINTF(",网速范围:%.2fM~%.2fM", m_rangeConfig.minNetworkSpeed, m_rangeConfig.maxNetworkSpeed));
			}
			else
			{
				result = true;
			}
			addListItem(downloadInfo.append(" 成功"));
		}
		else
		{
			setLastError("URLDownloadToFile下载文件失败");
		}
	} while (false);
	if (downloadVideo)
	{
		m_logData[LN_DOWNLOAD_SPEED] = LOG_INPUT("%s 网速 %.2f", OK_NG(result), networkSpeed);
	}
	return result;
}

bool DetectionTool::checkDvrRayAxis(const QString& url, const QString& dirName)
{
	bool result = true;
	do
	{
		QString localPath = QString("%1/%2/%3/%4").arg(getCurrentDir(), dirName, getCurrentDate(), getFileNameByUrl(url));
		IplImage* grayImage = cvLoadImage(Q_TO_C_STR(localPath), CV_LOAD_IMAGE_GRAYSCALE);
		if (!grayImage)
		{
			result = false;
			setLastError(QString("%1 无效的路径").arg(localPath));
			break;
		}
		grayBuffer_t grayBuffer = {};
		grayBuffer.buffer = (unsigned char*)grayImage->imageData;
		grayBuffer.height = grayImage->height;
		grayBuffer.width = grayImage->width;

		threshold_t threshold = {};
		threshold.xAxis = 100;
		threshold.yAxis = 100;

		axisStandard_t axisStandard = {};
		axisStandard.height = 40;
		axisStandard.width = 120;
		axisStandard.x = 100;
		axisStandard.y = 100;

		cross_t cross = {};
		cross = calculateCross(&grayBuffer, &threshold, &axisStandard);

		if (cross.iResult != 0)
		{
			addListItem("计算光轴失败");
		}
		cvReleaseImage(&grayImage);

		bool success = false;
		if (cross.x >= m_rangeConfig.minRayAxisX && cross.x <= m_rangeConfig.maxRayAxisX)
		{
			success = true;
		}
		else
		{
			result = success = false;
		}
		addListItem(Q_SPRINTF("光轴X:%.2f,范围:%.2f~%.2f %s"
			, cross.x, m_rangeConfig.minRayAxisX, m_rangeConfig.maxRayAxisX
			, success ? "OK" : "NG"));
		m_logData[LN_RAY_AXIS_X] = LOG_INPUT("%s 光轴X %.2f", OK_NG(success), cross.x);

		if (cross.y >= m_rangeConfig.minRayAxisY && cross.y <= m_rangeConfig.maxRayAxisY)
		{
			success = true;
		}
		else
		{
			result = success = false;
		}
		addListItem(Q_SPRINTF("光轴Y:%.2f,范围:%.2f~%.2f %s"
			, cross.y, m_rangeConfig.minRayAxisY, m_rangeConfig.maxRayAxisY
			, success ? "OK" : "NG"));
		m_logData[LN_RAY_AXIS_Y] = LOG_INPUT("%s 光轴Y %.2f", OK_NG(success), cross.y);

		if (cross.angle >= m_rangeConfig.minRayAxisA && cross.angle <= m_rangeConfig.maxRayAxisA)
		{
			success = true;
		}
		else
		{
			result = success = false;
		}
		addListItem(Q_SPRINTF("光轴角度:%.2f,范围:%.2f~%.2f %s"
			, cross.angle, m_rangeConfig.minRayAxisA, m_rangeConfig.maxRayAxisA
			, success ? "OK" : "NG"));
		m_logData[LN_RAY_AXIS_A] = LOG_INPUT("%s 光轴A %.2f", OK_NG(success), cross.angle);
	} while (false);
	return result;
}

bool DetectionTool::formatDvrSdCard(const dvrFormatSdCard_t& flag)
{
	setCurrentStatus("格式化SD卡");
	bool result = false;
	do
	{
		if (flag == DvrFormatSdCard::DFSC_BY_NETWORK)
		{
			if (!m_dvrClient.connectServer("10.0.0.10", 2000))
			{
				LOG_OUTPUT("连接服务器失败");
				break;
			}

			/*暂停录制*/

			/*							0	1	2	 3    4    5    6    7    8*/
			char pauseData[0x0D] = { 0xee,0xaa,0x03,0x00,0x00,0x00,0x02,0x00,0x00 };
			size_t crc32 = dvrCrc32Algorithom((uchar*)&pauseData[2], 7, 0);
			pauseData[9] = crc32 & 0xff;
			pauseData[10] = (crc32 >> 8) & 0xff;
			pauseData[11] = (crc32 >> 16) & 0xff;
			pauseData[12] = (crc32 >> 24) & 0xff;
			if (m_dvrClient.send(pauseData, 0x0D) == -1)
			{
				LOG_OUTPUT("发送失败");
				break;
			}

			char recvData[BUFF_SIZE] = { 0 };
			size_t startTime = GetTickCount();
			bool success = true;
			while (!((recvData[6] == 0x02) && (recvData[7] == 0x00)))
			{
				memset(recvData, 0x00, BUFF_SIZE);
				if (m_dvrClient.recv(recvData, BUFF_SIZE) == -1)
				{
					success = false;
					LOG_OUTPUT("接收失败");
					break;
				}

				if (GetTickCount() - startTime >= 10000)
				{
					success = false;
					break;
				}
			}

			if (!success)
			{
				LOG_OUTPUT("未接收到格式化报文");
				break;
			}

			if ((uchar)recvData[0] != 0xEE || (uchar)recvData[1] != 0xAA)
			{
				LOG_OUTPUT("无效的报文");
				break;
			}

			size_t data = -1;
			memcpy(&data, &recvData[8], sizeof(size_t));

#ifdef QT_DEBUG
			qDebug() << "暂停录制返回值:" << data << endl;
#endif

			success = (data == 0);

			addListItem(Q_SPRINTF("暂停循环录制 %s", OK_NG(success)));
			LOG_ASSERT(success, "暂停循环录制失败");

			/*							 0    1    2    3    4    5    6    7    8*/
			char sendData[0x0D] = { 0xee,0xaa,0x03,0x00,0x00,0x00,0x12,0x20,0x00 };
			crc32 = dvrCrc32Algorithom((uchar*)&sendData[2], 7, 0);
			sendData[9] = crc32 & 0xff;
			sendData[10] = (crc32 >> 8) & 0xff;
			sendData[11] = (crc32 >> 16) & 0xff;
			sendData[12] = (crc32 >> 24) & 0xff;
			if (m_dvrClient.send(sendData, 0x0D) == -1)
			{
				LOG_OUTPUT("发送失败");
				break;
			}

			startTime = GetTickCount();
			memset(recvData, 0x00, BUFF_SIZE);
			while (!((recvData[6] == 0x12) && (recvData[7] == 0x20)))
			{
				memset(recvData, 0x00, BUFF_SIZE);
				if (m_dvrClient.recv(recvData, BUFF_SIZE) == -1)
				{
					success = false;
					LOG_OUTPUT("接收失败");
					break;
				}

				if (GetTickCount() - startTime >= 10000)
				{
					success = false;
					break;
				}
			}

			if (!success)
			{
				LOG_OUTPUT("未接收到格式化报文");
				break;
			}

			if ((uchar)recvData[0] != 0xEE || (uchar)recvData[1] != 0xAA)
			{
				LOG_OUTPUT("无效的报文");
				break;
			}

			data = -1;
			memcpy(&data, &recvData[8], sizeof(size_t));

#ifdef QT_DEBUG
			qDebug() << "格式化返回值:" << data << endl;
#endif

			if (data != 0)
			{
				setLastError("格式化SD卡失败");
				break;
			}
		}
		result = true;
	} while (false);
	if (flag == DvrFormatSdCard::DFSC_BY_NETWORK)
	{
		m_dvrClient.closeConnect();
	}
	addListItemEx(Q_SPRINTF("格式化SD卡 %s", OK_NG(result)));
	m_logData[LN_FORMAT_SD] = LOG_INPUT("%s 格式化SD卡", OK_NG(result));
	return result;
}

void DetectionTool::startDvrTimeSync()
{
	MsgNode msg;
	memset(&msg, 0x00, sizeof(msg));
	msg.id = 0x511;
	msg.iDLC = 8;
	SYSTEMTIME time;
	GetLocalTime(&time);

	/*发送时间同步*/
	msg.ucData[0] = time.wSecond << 2;
	msg.ucData[1] = (0x1f & time.wHour) >> 3;
	msg.ucData[2] = (0x07 & time.wHour) << 5;
	msg.ucData[1] |= (0x3f & time.wMinute) << 2;
	msg.ucData[2] |= (0x1f & time.wDay) >> 3;
	msg.ucData[3] = (0x07 & time.wDay) << 5;
	msg.ucData[3] |= (0x1f & (time.wYear - 2014)) >> 4;
	msg.ucData[4] = (0x0f & (time.wYear - 2014)) << 4;
	msg.ucData[3] |= (0x0f & time.wMonth) << 1;

	//m_canMatrixTool.pack(msg.ucData, 7, 6, time.wSecond);
	//m_canMatrixTool.pack(msg.ucData, 9, 5, time.wHour);
	//m_canMatrixTool.pack(msg.ucData, 15, 6, time.wMinute);
	//m_canMatrixTool.pack(msg.ucData, 17, 5, time.wDay);
	//m_canMatrixTool.pack(msg.ucData, 24, 5, time.wYear - 2014);
	//m_canMatrixTool.pack(msg.ucData, 28, 4, time.wMonth);
	m_canSender.AddMsg(msg, 1000);
	m_canSender.Start();
	msleep(1000);
	return;
}

void DetectionTool::stopDvrTimeSync()
{
	m_canSender.DeleteOneMsg(0x511);
	m_canSender.Stop();
	return;
}

bool DetectionTool::setDvrSoundLight(bool enable)
{
	bool result = false;
	do
	{
		if (!m_relay.SetOneIO(m_relayConfig.led, enable))
		{
			break;
		}

		msleep(300);

		if (!m_relay.SetOneIO(m_relayConfig.sound, true))
		{
			break;
		}

		msleep(150);

		if (!m_relay.SetOneIO(m_relayConfig.sound, false))
		{
			break;
		}
		m_soundLight = enable;
		result = true;
	} while (false);
	return result;
}

bool DetectionTool::getDvrSoundLigth()
{
	return m_soundLight;
}

bool DetectionTool::checkDvrSfr(const QString& url, const QString& dirName)
{
	bool result = false;
	do
	{
		QString localPath = QString("%1/%2/%3/%4")
			.arg(getCurrentDir(), dirName, getCurrentDate(), getFileNameByUrl(url));
		IplImage* source = cvLoadImage(Q_TO_C_STR(localPath));
		if (!source)
		{
			LOG_OUTPUT("加载图像失败");
			break;
		}

		QString destFile = localPath;
		destFile.replace(".jpg", ".bmp");
		cvSaveImage(Q_TO_C_STR(destFile), source);
		cvReleaseImage(&source);

		float value = 0.0f;
		if (!m_sfrServer.getSfr(destFile, value))
		{
			LOG_OUTPUT(m_sfrServer.getLastError());
			break;
		}

		result = ((value >= m_rangeConfig.minSfr) && (value <= m_rangeConfig.maxSfr));
		addListItem(Q_SPRINTF("图像解像度:%.2f,范围:%.2f~%.2f %s"
			, value, m_rangeConfig.minSfr, m_rangeConfig.maxSfr, OK_NG(result)));
		m_logData[LN_SFR_VALUE] = LOG_INPUT("%s 解析度 %.2f", OK_NG(result), value);
	} while (false);
	return result;
}

bool DetectionTool::startExternalProgram(const QString& program, int show)
{
	bool result = false;
	do
	{
		/*判断是否有附加参数*/
		QString cmdLine;
		if (program.indexOf(" ") != -1)
		{
			cmdLine = program.mid(program.indexOf(" ") + 1);
		}

		QString destProgram = getCurrentDir() + '\\' + program;

		QString destDirectory = destProgram.mid(0, destProgram.lastIndexOf('\\'));

		HINSTANCE hInstance = ShellExecuteW(NULL, L"open", Q_TO_WC_STR(destProgram),
			cmdLine.isEmpty() ? NULL : Q_TO_WC_STR(cmdLine), Q_TO_WC_STR(destDirectory), show);
		if ((int)hInstance <= 32)
		{
			setLastError(QString("打开%1应用程序失败").arg(destProgram));
			break;
		}
		result = true;
	} while (false);
	return result;
}

bool DetectionTool::finishExternalProgram(const QString& file)
{
	bool result = false;
	do
	{
		QProcess process;
		process.start(QString("cmd.exe /c tasklist | findstr \"%1\"").arg(file));
		process.waitForFinished();

		QString output(process.readAllStandardOutput().data());

		if (output.indexOf(file) == -1)
		{
			break;
		}
		QProcess::execute("cmd.exe", { "/c","taskkill","/im",file,"/f" });
		result = true;
	} while (false);
	return result;
}

bool DetectionTool::changeIpAddress(const QString& destAddr, const QString& subnetMask, const QString& gateway, const int& id)
{
	bool result = false;
	do
	{
		getPhysicalAdapterInfo(&m_ipAdapterInfo, id);

		QString adapterName = "本地连接";

		if (id > 1)
		{
			adapterName.append(" " + QString::number(id));
		}

		QString cmdLine = QString("netsh interface ip set address name=\"%1\" source=static addr=%2 mask=%3 gateway=%4")
			.arg(adapterName, destAddr, subnetMask, gateway);

		QProcess::execute("cmd.exe", { "/c",cmdLine });
		result = true;
	} while (false);
	return result;
}

bool DetectionTool::restoreIpAddress()
{
	bool result = false;
	do
	{
		const char* adapterName = "Realtek PCIe GBE Family Controller";

		/*判断是否有效*/
		if (strncmp(m_ipAdapterInfo.Description, adapterName, strlen(adapterName)))
		{
			break;
		}

		int id = 1;
		const char* pointer = strrchr(m_ipAdapterInfo.Description, '#');

		/*判断是否不为第一块网卡*/
		if (pointer)
		{
			id = atoi(pointer + 1);
		}

		QString addressName = "本地连接";
		if (id > 1)
		{
			addressName.append(" " + QString::number(id));
		}

		QString cmdLine;
		if (m_ipAdapterInfo.DhcpEnabled)
		{
			cmdLine = QString("netsh interface ip set address name=\"%1\" source=dhcp").arg(addressName);
		}
		else
		{
			QStringList adapterList = {
			m_ipAdapterInfo.IpAddressList.IpAddress.String,
			m_ipAdapterInfo.IpAddressList.IpMask.String,
			m_ipAdapterInfo.GatewayList.IpAddress.String
			};

			cmdLine = QString("netsh interface ip set address name=\"%1\" source=static addr=%2 mask=%3 gateway=%4")
				.arg(addressName, adapterList[0], adapterList[1], adapterList[2]);
		}

		QProcess::execute("cmd.exe", { "/c",cmdLine });
		result = true;
	} while (false);
	return result;
}

bool DetectionTool::getPhysicalAdapterInfo(IP_ADAPTER_INFO* info, const int& id)
{
	bool result = false;
	do
	{
		ulong infoSize = sizeof(IP_ADAPTER_INFO);
		PIP_ADAPTER_INFO pAdapterInfo = (IP_ADAPTER_INFO*)HeapAlloc(GetProcessHeap(), 0, sizeof(IP_ADAPTER_INFO));
		if (!pAdapterInfo)
		{
			break;
		}

		if (GetAdaptersInfo(pAdapterInfo, &infoSize) == ERROR_BUFFER_OVERFLOW)
		{
			HeapFree(GetProcessHeap(), 0, pAdapterInfo);
			pAdapterInfo = (IP_ADAPTER_INFO*)HeapAlloc(GetProcessHeap(), 0, infoSize);
			if (!pAdapterInfo)
			{
				break;
			}
		}

		QString adapterName = "Realtek PCIe GBE Family Controller";

		if (id > 1)
		{
			adapterName.append(Q_SPRINTF(" #%d", id));
		}

		if (GetAdaptersInfo(pAdapterInfo, &infoSize) == NO_ERROR)
		{
			PIP_ADAPTER_INFO pAdapter = pAdapterInfo;
			while (pAdapter)
			{
				//"Realtek PCIe GBE Family Controller #2";
				/*确定100%为第一块物理网卡*/
				if ((pAdapter->Type == MIB_IF_TYPE_ETHERNET) && !strcmp(pAdapter->Description, Q_TO_C_STR(adapterName)))
				{
					memcpy(info, pAdapter, sizeof(IP_ADAPTER_INFO));
					result = true;
					break;
				}
				pAdapter = pAdapter->Next;
			}
		}

		if (pAdapterInfo)
		{
			HeapFree(GetProcessHeap(), 0, pAdapterInfo);
		}
	} while (false);
	return result;
}

const int DetectionTool::getPhysicalAdapterCount()
{
	int result = 0;
	do
	{
		ulong infoSize = sizeof(IP_ADAPTER_INFO);
		PIP_ADAPTER_INFO pAdapterInfo = (IP_ADAPTER_INFO*)HeapAlloc(GetProcessHeap(), 0, sizeof(IP_ADAPTER_INFO));
		if (!pAdapterInfo)
		{
			break;
		}

		if (GetAdaptersInfo(pAdapterInfo, &infoSize) == ERROR_BUFFER_OVERFLOW)
		{
			HeapFree(GetProcessHeap(), 0, pAdapterInfo);
			pAdapterInfo = (IP_ADAPTER_INFO*)HeapAlloc(GetProcessHeap(), 0, infoSize);
			if (!pAdapterInfo)
			{
				break;
			}
		}
		const char* description = "Realtek PCIe GBE Family Controller";
		if (GetAdaptersInfo(pAdapterInfo, &infoSize) == NO_ERROR)
		{
			PIP_ADAPTER_INFO pAdapter = pAdapterInfo;
			while (pAdapter)
			{
				if (pAdapter->Type == MIB_IF_TYPE_ETHERNET && !strncmp(pAdapter->Description, description, strlen(description)))
				{
					result++;
				}
				pAdapter = pAdapter->Next;
			}
		}

		if (pAdapterInfo)
		{
			HeapFree(GetProcessHeap(), 0, pAdapterInfo);
		}
	} while (false);
	return result;
}

IConnMgr* DetectionTool::getCanConnect()
{
	return m_canConnMgr;
}

CanSender& DetectionTool::getCanSend()
{
	return m_canSender;
}

const float& DetectionTool::getCanRouseCur()
{
	return m_thresholdConfig.canRouse;
}

CItechSCPIMgr& DetectionTool::getPower()
{
	return m_power;
}

const JsonTool* const DetectionTool::getJsonTool()
{
	return JsonTool::getInstance();
}

const DetectionType& DetectionTool::getDetectionType()
{
	return m_detectionType;
}

void dynamicDisplay(void* arg, void* parent)
{
	reinterpret_cast<DetectionTool*>(parent)->addListItem(G_TO_Q_STR(static_cast<char*>(arg)));
}

#if OPEN_VIDEO
/************************************************************************/
/* MIL采集卡处理线程													*/
/************************************************************************/
MilCaptureThread::MilCaptureThread(QObject* parent)
{
	m_threadHandler = reinterpret_cast<DetectionTool*>(parent);
}

MilCaptureThread::~MilCaptureThread()
{
	if (isRunning())
	{
		wait(5000);
	}
	m_threadHandler = nullptr;
}

bool MilCaptureThread::openMil(const QString& name)
{
	bool result = false;
	do
	{
		if (!MappAlloc(M_DEFAULT, &MilApplication))
		{
			setLastError("MappAlloc失败");
			break;
		}

		if (!MsysAlloc(M_SYSTEM_MORPHIS, M_DEF_SYSTEM_NUM, M_SETUP, &MilSystem))
		{
			setLastError("MsysAlloc失败");
			break;
		}

		if (!MdigAllocA(MilSystem, M_DEFAULT, name.toLocal8Bit().data(), M_DEFAULT, &MilDigitizer))
		{
			setLastError("MdigAlloc失败");
			break;
		}

		MIL_INT miX = MdigInquire(MilDigitizer, M_SIZE_X, M_NULL);
		MIL_INT miY = MdigInquire(MilDigitizer, M_SIZE_Y, M_NULL);
		MIL_INT miBand = MdigInquire(MilDigitizer, M_SIZE_BAND, M_NULL);
		MbufAllocColor(MilSystem,
			miBand,
			miX,
			miY,
			8L + M_UNSIGNED,
			M_IMAGE + M_BASIC_BUFFER_PURPOSE,
			&MilImage);
		MdigControl(MilDigitizer, M_GRAB_MODE, M_SYNCHRONOUS);
		MdigControl(MilDigitizer, M_CAMERA_LOCK, M_ENABLE);

		MdigControl(MilDigitizer, M_GRAB_AUTOMATIC_INPUT_GAIN, M_DISABLE);
		MdigControl(MilDigitizer, M_GRAB_INPUT_GAIN, 50);

		MappControl(M_ERROR, M_PRINT_DISABLE);

		MbufClear(MilImage, 0);

		if (!MilDigitizer)
		{
			setLastError("MilDigitizer失败");
			break;
		}
		MdigGrabContinuous(MilDigitizer, MilImage);
		result = true;
	} while (false);

	return result;
}

void MilCaptureThread::closeMil()
{
	MdigHalt(MilDigitizer);
	MbufFree(MilImage);
	MdigFree(MilDigitizer);
	MsysFree(MilSystem);
	MappFree(MilApplication);
}

void MilCaptureThread::startCapture()
{
	m_capture = true;
}

void MilCaptureThread::endCapture()
{
	m_capture = false;
}

const QString& MilCaptureThread::getLastError()
{
	return m_lastError;
}

void MilCaptureThread::run()
{
	static QImage image;
	IplImage* currentImage = cvCreateImage(cvSize(m_threadHandler->m_captureCard.width, m_threadHandler->m_captureCard.height), 8, 3);
	if (!currentImage)
	{
		setLastError("currentImage分配内存失败");
		return;
	}

	while (!m_threadHandler->m_quit)
	{
		if (m_threadHandler->m_connect && m_capture)
		{
			MbufGetColor(MilImage, M_PACKED + M_BGR24, M_ALL_BANDS, currentImage->imageData);
			MbufClear(MilImage, 0);

			if (m_threadHandler->m_capture)
			{
				memcpy(m_threadHandler->m_cvAnalyze->imageData, currentImage->imageData, m_threadHandler->m_captureCard.size);
				m_threadHandler->m_capture = false;
			}

			m_threadHandler->drawRectOnImage(currentImage);

			if (m_threadHandler->cvImageToQtImage(currentImage, &image))
			{
				m_threadHandler->updateImage(image);
			}
		}
		msleep(40);
	}
	cvReleaseImage(&currentImage);
	quit();
}

void MilCaptureThread::setLastError(const QString& err)
{
#ifdef QT_DEBUG
	qDebug() << err << endl;
#endif// !QT_DEBUG
	m_lastError = err;
}

/************************************************************************/
/* MV800采集卡线程														*/
/************************************************************************/
static void __stdcall Mv800CaptureThread(const uchar* pDIBHead, const uchar* pDIBits, LPVOID pParam)
{
	static QImage image;

	DetectionTool* threadHandler = reinterpret_cast<DetectionTool*>((static_cast<VideoSteamParam*>(pParam))->pArgs);
	if (!threadHandler)
	{
		return;
	}

	if (threadHandler->m_connect)
	{
		threadHandler->m_cvPainting->imageData = (char*)pDIBits;
		if (threadHandler->m_capture)
		{
			memcpy(threadHandler->m_cvAnalyze->imageData, pDIBits, threadHandler->m_captureCard.size);
			cvFlip(threadHandler->m_cvAnalyze, threadHandler->m_cvAnalyze, 0);
			threadHandler->m_capture = false;
		}

		/*将镜像视图转为正常视图*/
		cvFlip(threadHandler->m_cvPainting, threadHandler->m_cvPainting, 0);

		threadHandler->drawRectOnImage(threadHandler->m_cvPainting);

		if (threadHandler->cvImageToQtImage(threadHandler->m_cvPainting, &image))
		{
			threadHandler->updateImage(image);
		}
	}
	return;
}

#endif// !OPEN_VIDEO

const QString getFileNameByUrl(const QString& url)
{
	return url.mid(url.lastIndexOf("/") + 1);
}

const QString getFileNameByPath(const QString& path)
{
	return path.mid(path.lastIndexOf('\\') + 1);
}

const QString getCurrentFileName()
{
	QString fileName = "";
	do
	{
		char buffer[MAX_PATH] = { 0 };
		if (!GetModuleFileNameA(NULL, buffer, MAX_PATH))
		{
			break;
		}
		QString fullName(G_TO_Q_STR(buffer));
		fileName = fullName.mid(fullName.lastIndexOf('\\') + 1);
	} while (false);
	return fileName;
}

const QString getCurrentDir()
{
	char buffer[BUFF_SIZE] = { 0 };
	GetCurrentDirectoryA(BUFF_SIZE, buffer);
	return G_TO_Q_STR(buffer);
}

const QString getAppVersion()
{
	QString result = "0.0.0";
	char* nameBuffer = nullptr;
	do
	{

		char fullName[MAX_PATH] = { 0 };
		if (!GetModuleFileNameA(NULL, fullName, MAX_PATH))
		{
			break;
		}

		quint32 nameLen = GetFileVersionInfoSizeA(fullName, 0);
		if (!nameLen)
		{
			break;
		}

		nameBuffer = new(std::nothrow) char[nameLen + 1];
		if (!nameBuffer)
		{
			break;
		}

		bool success = GetFileVersionInfoA(fullName, 0, nameLen, nameBuffer);
		if (!success)
		{
			break;
		}

		struct LanguageCodePage
		{
			WORD language;
			WORD codePage;
		} *translate;

		quint32 queryLen = 0;
		success = VerQueryValue(nameBuffer, (TEXT("\\VarFileInfo\\Translation")), (LPVOID*)&translate, &queryLen);
		if (!success)
		{
			break;
		}
		QString str1, str2;
		str1.setNum(translate->language, 16);
		str2.setNum(translate->codePage, 16);
		str1 = "000" + str1;
		str2 = "000" + str2;
		QString verPath = "\\StringFileInfo\\" + str1.right(4) + str2.right(4) + "\\FileVersion";
		void* queryBuffer = nullptr;
		success = VerQueryValue(nameBuffer, (verPath.toStdWString().c_str()), &queryBuffer, &queryLen);
		if (!success)
		{
			break;
		}
		result = QString::fromUtf16((const unsigned short int*)queryBuffer);
	} while (false);
	if (nameBuffer)
	{
		delete[] nameBuffer;
		nameBuffer = nullptr;
	}
	return result;
}

bool renameAppByVersion(QWidget* widget)
{
	bool result = false;
	do
	{
		auto deviceConfig = JsonTool::getInstance()->getParsedDeviceConfig();
		widget->setWindowTitle(QString("%1%2检测[%3]")
			.arg(deviceConfig.modelName, deviceConfig.detectionName, getAppVersion()));

		QString oldName(getCurrentFileName());
		QString newName = QString("%1%2检测[%3].exe")
			.arg(deviceConfig.modelName, deviceConfig.detectionName, getAppVersion());
		if (oldName != newName)
		{
			QFile::rename(oldName, newName);
		}
		result = true;
	} while (false);
	return result;
}

void DvrClient::setLastError(const QString& err)
{
#ifdef QT_DEBUG
	qDebug() << err << endl;
#endif
	m_lastError = err;
}

DvrClient::DvrClient()
{

}

DvrClient::~DvrClient()
{
	if (!m_close)
	{
		closesocket(m_socket);
		WSACleanup();
	}
}

#include <wincon.h>
bool DvrClient::connectServer(const char* ipAddr, const ushort& port, const int& protocol)
{
	bool result = false;
	do
	{
		if (m_init)
		{
			result = true;
			break;
		}

		memset(m_ipAddr, 0x00, sizeof(m_ipAddr));
		strcpy(m_ipAddr, ipAddr);
		m_port = port;

		WORD sockVersion = MAKEWORD(2, 2);
		WSADATA wsaData;
		if (WSAStartup(sockVersion, &wsaData) != 0)
		{
			setLastError("初始化失败");
			break;
		}

		m_socket = socket(AF_INET, protocol, 0);

		if (m_socket == -1)
		{
			setLastError("套接字初始化失败");
			break;
		}

		int timeout = 3000;

		setsockopt(m_socket, SOL_SOCKET, SO_SNDTIMEO, (const char*)&timeout, sizeof(timeout));
		setsockopt(m_socket, SOL_SOCKET, SO_RCVTIMEO, (const char*)&timeout, sizeof(timeout));


		memset(&m_sockAddr, 0x00, sizeof(sockaddr_in));
		m_sockAddr.sin_addr.S_un.S_addr = inet_addr(ipAddr);
		m_sockAddr.sin_family = AF_INET;
		m_sockAddr.sin_port = htons(port);

		timeval tv;
		fd_set set;
		ulong argp = 1;
		ioctlsocket(m_socket, FIONBIO, &argp);
		bool success = false;
		int error = -1;
		int length = sizeof(int);
		for (size_t i = 0; i < 10; i++)
		{
			if (connect(m_socket, (const sockaddr*)&m_sockAddr, sizeof(m_sockAddr)) == -1)
			{
				tv.tv_sec = 1;
				tv.tv_usec = 0;
				FD_ZERO(&set);
				FD_SET(m_socket, &set);

				if (select(m_socket + 1, NULL, &set, NULL, &tv) > 0)
				{
					getsockopt(m_socket, SOL_SOCKET, SO_ERROR, (char*)&error, &length);
					if (error == 0)
					{
						success = true;
						break;
					}
					else
					{
						success = false;
					}
				}
				else
				{
					success = false;
				}
			}
			else
			{
				success = true;
				break;
			}
		}

		argp = 0;
		ioctlsocket(m_socket, FIONBIO, &argp);

		if (!success)
		{
			setLastError("连接服务器超时");
			break;
		}
		m_init = result = true;
		m_close = false;
	} while (false);
	return result;
}

int DvrClient::send(char* buffer, int len)
{

	int result = 0, count = 0;
	count = len;

	while (count > 0)
	{
		result = ::send(m_socket, buffer, count, 0);
		if (result == SOCKET_ERROR)
		{
			return -1;
		}

		if (result == 0)
		{
			return len - count;
		}

		buffer += result;
		count -= result;
	}
	return len;
}

int DvrClient::recv(char* buffer, int len)
{
	char temp[6] = { 0 };
	int result = ::recv(m_socket, temp, sizeof(temp), 0);
	if (result != sizeof(temp))
	{
		return -1;
	}

	int recvLen = 0;
	memcpy(&recvLen, &temp[2], sizeof(int));
#ifdef QT_DEBUG
	qDebug() << "接收长度:" << recvLen << endl;
#endif
	memcpy(buffer, temp, sizeof(temp));

	int count = recvLen + 4;//crc 4个字节
	buffer += sizeof(temp);
	while (count > 0)
	{
		result = ::recv(m_socket, buffer, recvLen + 4, 0);
		if (result == SOCKET_ERROR)
		{
			return -1;
		}

		if (result == 0)
		{
			return recvLen - count;
		}
		buffer += result;
		count -= result;
	}
	return recvLen + sizeof(temp);
}

const char* DvrClient::getIpAddr()
{
	return m_ipAddr;
}

const ushort& DvrClient::getPort()
{
	return m_port;
}

void DvrClient::closeConnect()
{
	closesocket(m_socket);
	WSACleanup();
	m_init = false;
	m_close = true;
}

const QString& DvrClient::getLastError()
{
	return m_lastError;
}

void SfrServer::setLastError(const QString& err)
{
	m_lastError = err;
}

SfrServer::SfrServer()
{
}

SfrServer::~SfrServer()
{
	m_quit = true;
	closesocket(m_socket);
	WSACleanup();
}

void sfrServerProc(void* arg)
{
	SfrServer* sfrServer = (SfrServer*)arg;
	while (!sfrServer->m_quit)
	{
		sockaddr_in clientAddr;
		int addrLen = sizeof(sockaddr_in);
		SOCKET clientSocket = accept(sfrServer->m_socket, (sockaddr*)&clientAddr, &addrLen);
		if (clientSocket == -1)
		{
			break;
		}
		sfrServer->m_client = clientSocket;
#ifdef QT_DEBUG
		qDebug() << "新客户端已连接" << endl;
#endif
		Sleep(100);
	}
	return;
}

bool SfrServer::startListen(const ushort& port)
{
	bool result = false;
	do
	{
		WORD sockVersion = MAKEWORD(2, 2);
		WSADATA wsaData;
		if (WSAStartup(sockVersion, &wsaData) != 0)
		{
			setLastError("WSAStartup初始化失败");
			break;
		}

		m_socket = socket(AF_INET, SOCK_STREAM, 0);

		if (m_socket == -1)
		{
			setLastError("SOCKET初始化失败");
			break;
		}

		int timeout = 1000, optval = 1;
		setsockopt(m_socket, SOL_SOCKET, SO_SNDTIMEO, (const char*)&timeout, sizeof(timeout));
		setsockopt(m_socket, SOL_SOCKET, SO_RCVTIMEO, (const char*)&timeout, sizeof(timeout));
		setsockopt(m_socket, SOL_SOCKET, SO_REUSEADDR, (const char*)&optval, sizeof(optval));

		memset(&m_sockAddr, 0x00, sizeof(sockaddr_in));
		m_sockAddr.sin_addr.S_un.S_addr = INADDR_ANY;
		m_sockAddr.sin_family = AF_INET;
		m_sockAddr.sin_port = htons(port);

		if (bind(m_socket, (const sockaddr*)&m_sockAddr, sizeof(SOCKADDR_IN)) == -1)
		{
			setLastError("绑定失败");
			break;
		}

		if (listen(m_socket, 128) == -1)
		{
			setLastError("监听失败");
			break;
		}
		_beginthread(sfrServerProc, 0, this);
		result = true;
	} while (false);
	return result;
}

bool SfrServer::getSfr(const QString& filePath, float& sfr)
{
	bool result = false;
	do
	{
		int sendLen = 208;
		char sendData[256] = { 0 };

		sprintf(sendData, "$THC001%s", Q_TO_C_STR(filePath));
		sendData[sendLen - 1] = '$';
		int count = ::send(m_client, sendData, sendLen, 0);
		if (count != sendLen)
		{
			setLastError("发送失败");
			break;
		}

		int recvLen = 208;
		char recvData[256] = { 0 };
		count = ::recv(m_client, recvData, recvLen, 0);
		if (count == -1 || recvData[0] != '$')
		{
			sfr = 0.0f;
		}
		else
		{
			if (strncmp(recvData, "$HTR000", 7))
			{
				setLastError("SFR客户端数据异常");
				break;
			}

			if (sscanf(&recvData[7], "%f", &sfr) != 1)
			{
				setLastError("SFR客户端数据异常");
				break;
			}
		}
		result = true;
	} while (false);
	return result;
}

int SfrServer::send(SOCKET socket, char* buffer, int len)
{
	int count = len, result = 0;
	while (count > 0)
	{
		result = ::send(socket, buffer, count, 0);
		if (result == -1)
		{
			return -1;
		}

		if (result == 0)
		{
			return len - count;
		}

		buffer += result;
		count -= result;
	}
	return len;
}

int SfrServer::recv(SOCKET socket, char* buffer, int len)
{
	int count = len, result = 0;
	while (count > 0)
	{
		result = ::recv(socket, buffer, count, 0);
		if (result == -1)
		{
			return -1;
		}

		if (result == 0)
		{
			return len - count;
		}

		buffer += result;
		count -= result;
	}
	return len;
}

void SfrServer::closeServer()
{
	m_quit = true;
}

const QString& SfrServer::getLastError()
{
	return m_lastError;
}
